# cd-bookmark - zsh plugin to bookmark directories to cd.
#
# Copyright (c) 2014 Hideaki Miyake
# Licensed under the MIT License (MIT)
#
# Author : Hideaki Miyake (https://github.com/mollifier)
# URL : https://github.com/mollifier/cd-bookmark
#
# How to set up
#   Put cd-bookmark and _cd-bookmark files somewhere in your $fpath
#   and add this line to your .zshrc:
#
#     autoload -Uz cd-bookmark
#
# Usage:
#   cd-bookmark [PATH]
#

typeset -r SCRIPT_NAME="cd-bookmark"
typeset -r BOOKMARK_FILE=~/.cdbookmark

function print_usage()
{
    cat << EOF
Usage: $SCRIPT_NAME -a [BOOKMARK_ID]  (1st form)
  or:  $SCRIPT_NAME [-c] BOOKMARK_ID  (2nd form)
  or:  $SCRIPT_NAME [-l]              (3rd form)
$SCRIPT_NAME is a command to bookmark directories.
In the 1st form, add current directory to bookmark with BOOKMARK_ID.
BOOKMARK_ID is used as a key in bookmark.
In the 2nd form, find directory by BOOKMARK_ID and change directory to it.
In the 3rd form, list current bookmark.

  -a [BOOKMARK_ID]   add current directory to bookmark
                     with no BOOKMARK_ID, automatically use free ID number as BOOKMARK_ID
  -c BOOKMARK_ID     change directory which is identified by BOOKMARK_ID
  -l                 list bookmark
  -e                 edit bookmark file
  -h                 display this help and exit
EOF
}

function print_error()
{
    echo "$SCRIPT_NAME: $@" 1>&2
    echo "Try \`-h' option for more information." 1>&2
}

function edit_bookmark() {
  # open BOOKMARK_FILE with EDITOR.
  ${EDITOR:-vi} "$BOOKMARK_FILE"
}

function list_bookmark() {
  cat "$BOOKMARK_FILE" | sort -n
}

function list_bookmark_path() {
  cat "$BOOKMARK_FILE" | cut -d '|' -f 2
}

function list_bookmark_id() {
  cat "$BOOKMARK_FILE" | cut -d '|' -f 1
}

function get_bookmark() {
  escaped_bmid=$(echo "$1" | sed -e 's/[^a-zA-Z0-9<>]/\\&/g')
  cat "$BOOKMARK_FILE" | grep -E "^${escaped_bmid}\\|" | cut -d '|' -f 2 | head -n 1
}

function cd_to_bookmark() {
  local bookmark_id="$1"
  local bookmark_dir=$(get_bookmark "$bookmark_id")
  if [ -z "$bookmark_dir" ]; then
    print_error "$bookmark_id is not in bookmark list" 1>&2
    return 1
  fi

  cd "$bookmark_dir"
}

function add_to_bookmark() {
  local bmdir=$PWD
  local newid=$1

  if list_bookmark_path | grep -F -x "$bmdir" > /dev/null; then
    echo "$bmdir is already in bm list" 1>&2
    return 2
  fi

  if [ -n "$newid" ]; then
    if list_bookmark_id | grep -F -x "$newid" > /dev/null; then
      echo "$newid is already used as bm id" 1>&2
      return 3
    fi
  fi

  if [ -z $newid ]; then
    local maxid
    maxid=$(list_bookmark_id | grep '^[0-9][0-9]*$' | sort -n -r | head -1)
    if [ -n "$maxid" ] && [ "$maxid" -ge 1 ]; then
      newid=$((maxid + 1))
    else
      newid=1
    fi
  fi

  echo "$newid|$bmdir" >> "$BOOKMARK_FILE"
}
# main function
function cdbookmark() {

  # mode : add, cd, list, edit
  local mode=""
  local bookmark_id=""

  while getopts ':a:c:leh' option; do
    case $option in
      a)
        bookmark_id="$OPTARG"
        mode="add"
        ;;
      c)
        bookmark_id="$OPTARG"
        mode="cd"
        ;;
      l)
        mode="list"
        ;;
      e)
        mode="edit"
        ;;
      h)
        print_usage
        return 0
        ;;
      :)
        print_error "option requires an argument -- $OPTARG"
        return 1
        ;;
      *)
        print_error "invalid option -- $OPTARG"
        return 1
        ;;
    esac
  done
  shift $(expr $OPTIND - 1)

  # with no option, cd or list bookmarks
  if [ -n "$mode" ]; then
    bookmark_id="$1"

    if [ -n "$bookmark_id" ]; then
      mode="cd"
    else
      mode="list"
    fi
  fi

  case "$mode" in
    add)
      add_to_bookmark "$bookmark_id"
      ;;
    cd)
      cd_to_bookmark "$bookmark_id"
      ;;
    list)
      list_bookmark
      ;;
    edit)
      edit_bookmark
      ;;
  esac
}

cdbookmark "$@"

# vim:set ft=zsh:
